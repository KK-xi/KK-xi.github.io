<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" type="image/png" href="/img/avatar.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="记录生活">
  <meta name="author" content="kiki">
  <meta name="keywords" content="CV">
  <title>pytorch学习记录 - KK&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Welcome to here.</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/work/">工作</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/life/">生活</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期二, 三月 24日 2020, 10:50 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    4.6k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      19 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h2 id="课程名：《Pytorch-动态神经网络》">课程名：《Pytorch 动态神经网络》</h2>
<p>课程来源：<a href="https://www.bilibili.com/video/av15997678?p=35" target="_blank" rel="noopener">here</a><br>
作者：莫烦</p>
<h2 id="day01-安装Pytorch">day01 安装Pytorch</h2>
<p>前提：安装Anaconda参考别人的安装教程<a href="https://www.jianshu.com/p/742dc4d8f4c5" target="_blank" rel="noopener">https://www.jianshu.com/p/742dc4d8f4c5</a></p>
<ul>
<li>
<p>在开始菜单找到Anaconda的命令提示行(Anaconda Prompt)，并输入conda create -n pytorch python=3.7(我自己的是3.7版本)，建立一个Pytorch的环境：<br>
<img src="https://img-blog.csdnimg.cn/20200318180532330.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
</li>
<li>
<p>然后，出现以下情况，问是否安装等等工具包，选择[y]开始安装：<br>
<img src="https://img-blog.csdnimg.cn/20200318180734340.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_10,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
</li>
<li>
<p>安装成功以后，会出现如下，就是激活环境的语句：<br>
<img src="https://img-blog.csdnimg.cn/20200318180919400.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_10,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
</li>
<li>
<p>输入conda activate pytorch进入pytorch环境：<br>
<img src="https://img-blog.csdnimg.cn/20200318181124374.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
</li>
<li>
<p>输入pip list可以查看这个环境下的工具包，可以看到没有需要的pytorch，所以需要安装：<br>
<img src="https://img-blog.csdnimg.cn/2020031818131941.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_12,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
</li>
<li>
<p>去官网查看自己适合哪个版本，比如我的是CPU，习惯用pip，如下图：<img src="https://img-blog.csdnimg.cn/20200322091319185.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_1,color_FFFFFF,t_10" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<pre><code class="language-python">pip install torch==1.4.0+cpu torchvision==0.5.0+cpu -f https://download.pytorch.org/whl/torch_stable.html
</code></pre>
</li>
<li>
<p>完了以后，在pytorch环境中进入&gt;&gt;python，测试一下是否安装成功，输入import torch即可。</p>
</li>
</ul>
<h2 id="day02">day02</h2>
<h3 id="一、神经网络简介">一、神经网络简介</h3>
<p>1、 机器学习—梯度下降机制(optimization) <br><br>
2、神经网络黑盒：输入端-黑盒-输出端； <br><br>
　　　　　　黑盒：特征代表输入数据。</p>
<h3 id="二、why-Pytorch？">二、why Pytorch？</h3>
<p>1、与tensorflow的区别</p>
<ul>
<li>tensorflow是静态的框架，构建好tensorflow的计算图之后，这个计算图是不能改变的，计算流程是固定的，类似C++，写代码时要用他自己的一些API。缺点之一例如训练的时候loss一直将不下来，模型很难得到优化，debug就很困难。</li>
</ul>
<ul>
<li>pytorch是动态的框架，和python一样，直接计算，不用开启会话。 <br></li>
</ul>
<h3 id="三、Variable变量">三、Variable变量</h3>
<ul>
<li>
<p>在 Torch 中的 Variable 就是一个存放会变化的值的地理位置，里面的值会不停的变化，就像一个裝鸡蛋的篮子，鸡蛋数会不停变动。那里面的鸡蛋就是 Torch 的 Tensor 。</p>
</li>
<li>
<p>PyTorch采用动态图设计，可以很方便地查看中间层的输出，动态的设计计算图结构。</p>
</li>
<li>
<p>from torch.autograd import Variable</p>
<pre><code class="language-python">ten=torch.FloatTensor([[1,2],[3,4]]) # tensor的类型
variable=Variable(tensor,requires_grad=True) 
# 将tensor传给variable，需要Variable来建立一个计算图纸，把鸡蛋放到篮子里, requires_grad是参不参与误差反向传播, 要不要计算梯度，如果要就会计算Variable节点的梯度
t_out = torch.mean(ten*ten) # 计算x^2
v_out = torch.mean(variable*variable)

v_out.backward() # v_outbackward时，variable也会变化，因为是一体的
print(variable)
#直接print(variable)只会输出 Variable 形式的数据, 在很多时候是用不了的(比如想要用 plt 画图),所以我们要转换一下, 将它变成 tensor 形式
print(variable.data)
print(variable.data.numpy())# variable.data为tensor的形式，tensor才能转换为numpy形式
</code></pre>
</li>
<li>
<p>autograd根据用户对Variable的操作构建其计算图，这个图将所有的计算步骤 (节点) 都连接起来，最后进行误差反向传递的时候， 一次性将所有 variable 里面的修改幅度 (梯度) 都计算出来, 而 tensor 就没有这个能力。</p>
</li>
<li>
<p>variable默认是不需要求导的，即requires_grad属性默认为False，如果某一个节点requires_grad被设置为True，那么所有依赖它的节点requires_grad都为True。</p>
</li>
<li>
<p>多次反向传播时，<font color="red">梯度是累加的</font>。反向传播的中间缓存会被清空，为进行多次反向传播需指定retain_graph=True来保存这些缓存。</p>
</li>
<li>
<p>variable的grad与data形状一致，应避免直接修改variable.data，因为对data的直接操作无法利用autograd进行反向传播。</p>
</li>
</ul>
<h2 id="day-03">day 03</h2>
<h3 id="一、激励函数（Activation）">一、激励函数（Activation）</h3>
<ul>
<li>
<p>什么是Activation<br>
非线性的函数激活网络的输出：ReLU、Sigmoid、Tanh、Softplus</p>
</li>
<li>
<p>Torch中的激励函数</p>
<pre><code class="language-python">
import torch.nn.functional as F
from torch.autograd import Variable
import matplotlib.pyplot as plt
    
x = torch.linspace(-5, 5, 200)  # x data (tensor), shape=(100, 1)
x = Variable(x)
x_np = x.data.numpy()   # numpy 数据才能用来画图
    
y_relu = torch.relu(x).data.numpy()
y_sigmoid = torch.sigmoid(x).data.numpy()
y_tanh = torch.tanh(x).data.numpy() # 计算出非线性函数输出后也要转化为numpy数据
# y_softplus = F.softplus(x).data.numpy()   

#画图
plt.figure(1, figsize=(8, 6))
plt.subplot(221)
plt.plot(x_np, y_relu, c='red', label='relu')
plt.ylim((-1, 5))
plt.legend(loc='best')
</code></pre>
</li>
<li>
<p>结果<br>
<img src="https://img-blog.csdnimg.cn/2020032211361126.png?type_ZmFuZ3poZW5naGVpdGk,shadow_1,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_1,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="二、Regression回归">二、Regression回归</h3>
<p>直接放莫老师教的代码过来：</p>
<ul>
<li>
<p>Layer图搭建以及计算流程</p>
<pre><code class="language-python">class Net(torch.nn.Module):   # torch.nn.Module是Net的主模块
    def __init__(self, n_feature, n_hidden, n_output): # 搭建层所需要的信息
        super(Net, self).__init__()  # 继承Net的模块功能
        self.hidden = torch.nn.Linear(n_feature, n_hidden)   # hidden layer
        self.predict = torch.nn.Linear(n_hidden, n_output)   # output layer

    def forward(self, x): # 前向传递的过程，搭流程图
           x = F.relu(self.hidden(x))      # activation function for hidden layer
           x = self.predict(x)             # linear output
     return x
</code></pre>
</li>
</ul>
<ul>
<li>
<p>定义Net</p>
<pre><code class="language-python">net = Net(n_feature=1, n_hidden=10, n_output=1)     # define
</code></pre>
</li>
</ul>
<ul>
<li>
<p>优化神经网络(torch.optim.),以及loss function定义</p>
<pre><code class="language-python">optimizer = torch.optim.SGD(net.parameters(), lr=0.2)
loss_func = torch.nn.MSELoss() # 均方差作为loss
</code></pre>
</li>
<li>
<p>开始训练</p>
<pre><code class="language-python">for t in range(200):
    prediction = net(x)     # input x and predict based on x

    loss = loss_func(prediction, y)     # must be (1. nn output, 2. target)

    optimizer.zero_grad()   # clear gradients for next train
    loss.backward()         # backpropagation, compute gradients
    optimizer.step()        # apply gradients
    # 以上三步为优化步骤
</code></pre>
</li>
</ul>
<h3 id="三、Classification-分类">三、	Classification 分类</h3>
<p>与上面不同的是：</p>
<ul>
<li>构造的伪数据不一样，是包含有对应标签的数据；(数据不能是一维)</li>
<li>网络输入输出不同，有两个输入两个输出；</li>
<li>loss用到的是交叉熵cross entropy loss，out与标签y</li>
</ul>
<pre><code class="language-python">loss_func = torch.nn.CrossEntropyLoss() 
loss = loss_func(out, y)
</code></pre>
<ul>
<li>
<p>output是取值，转换成概率值需要加softmax(out)</p>
<pre><code class="language-python">out = net(x)     # input x and predict based on x
prediction = F.softmax(out)  #将输出对应值转化成概率
</code></pre>
</li>
</ul>
<h3 id="四、快速搭建网络">四、快速搭建网络</h3>
<ul>
<li>
<p>method1—搭建网络、流程图，定义网络</p>
<pre><code class="language-python">class Net(torch.nn.Module):
    def __init__(self, n_feature, n_hidden, n_output):
        super(Net, self).__init__()
        self.hidden = torch.nn.Linear(n_feature, n_hidden)   # hidden layer
        self.predict = torch.nn.Linear(n_hidden, n_output)   # output layer

    def forward(self, x):
        x = F.relu(self.hidden(x))      # activation function for hidden layer
        x = self.predict(x)             # linear output
        return x

net1 = Net(n_feature=2, n_hidden=10, n_output=2)  
</code></pre>
</li>
<li>
<p>method2—利用torch.nn.Sequential直接定义网络</p>
<pre><code class="language-python">net2=torch.nn.Sequential(
    torch.nn.Linear(2,10),
    torch.nn.ReLU(),
    torch.nn.Linear(10,2)
)
</code></pre>
</li>
</ul>
<h3 id="五、网络的保存和提取">五、网络的保存和提取</h3>
<ul>
<li>
<p>方法1：保存—提取</p>
<pre><code class="language-python">torch.save(net1, 'net.pkl') # 保存整个网络，以pkl形式保存
</code></pre>
<pre><code class="language-python">net2 = torch.load('net.pkl')
prediction = net2(x)
</code></pre>
</li>
<li>
<p>方法2：保存—提取</p>
<pre><code class="language-python">torch.save(net1.state_dict(), 'net_params.pkl') # 只保存网络中节点的参数 (速度快, 占内存少)
</code></pre>
<pre><code class="language-python">net3 = torch.nn.Sequential(
    torch.nn.Linear(1, 10),
    torch.nn.ReLU(),
    torch.nn.Linear(10, 1)
)
net3.load_state_dict(torch.load('net_params.pkl'))
prediction = net3(x)
</code></pre>
</li>
</ul>
<h3 id="六、批数据训练-mini-batch-training">六、批数据训练(mini_batch training)</h3>
<ul>
<li>
<p>将数据分批训练，一个epoch训练所有批次的数据：</p>
<pre><code class="language-python">import torch.utils.data as Data
BATCH_SIZE = 5 # 抽取训练的数据
# BATCH_SIZE = 8

x = torch.linspace(1, 10, 10)       # this is x data (torch tensor)
y = torch.linspace(10, 1, 10)       # this is y data (torch tensor)

torch_dataset = Data.TensorDataset(data_tensor = x, target_tensor = y)
loader = Data.DataLoader(
    dataset=torch_dataset,      # torch TensorDataset format
    batch_size=BATCH_SIZE,      # mini batch size
    shuffle=True,               # random shuffle for training
    num_workers=2,              # 多线程来读数据
)
	
for epoch in range(3):   # 训练所有!整套!数据 3 次
    for step, (batch_x, batch_y) in enumerate(loader):  # 每一步 loader 释放一小批数据用来学习
        # 假设这里就是你训练的地方...
        # 打出来一些数据
        print('Epoch: ', epoch, '| Step: ', step, '| batch x: ',
              batch_x.numpy(), '| batch y: ', batch_y.numpy())
</code></pre>
</li>
<li>
<p>DataLoader<br>
是PyTorch中数据读取的接口，PyTorch训练模型基本都会用到该接口，其目的：将dataset根据batch_size大小、shuffle等封装成一个Batch Size大小的Tensor，用于后面的训练。</p>
</li>
<li>
<p>enumerate()函数<br>
用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。在这里就是把是个数据分成size为5的两份数据后，将每一份数据对应的下标给step，数据给(batch_x, batch_y)。</p>
</li>
</ul>
<h2 id="day-04">day 04</h2>
<h3 id="一、优化器Optimizer加速神经网络训练（深度学习）">一、优化器Optimizer加速神经网络训练（深度学习）</h3>
<ul>
<li>数据分批送入网络，进行SGD优化；</li>
<li>Momentum更新参数方法：$m=b1<em>m-Learningrate</em>dx,W+=m$</li>
<li>AdaGrad：$v+=dx^2，W+=-Learning rate*dx/\sqrt v$</li>
<li>RMSProp方法(上述两种的合并)：$v=b1*v+(1-b1)<em>dx^2,W+=-Learning_rate</em>dx/\sqrt v$</li>
<li>Adam:$m = b1*m+(1-b1)<em>dx$——&gt;Momentum<br>
　　　 $v = b2</em>v+(1-b2)<em>dx^2$——&gt;AdaGrad<br>
　　　 $W+=-Learning_rate</em>m/\sqrt v$</li>
</ul>
<h3 id="二、Opttimizer优化器">二、Opttimizer优化器</h3>
<ul>
<li>
<p>几种常见优化器：</p>
<pre><code class="language-python"># different optimizers
opt_SGD = torch.optim.SGD(net_SGD.parameters(), lr=LR)
opt_Momentum = torch.optim.SGD(net_Momentum.parameters(), lr=LR, momentum=0.8)
opt_RMSprop = torch.optim.RMSprop(net_RMSprop.parameters(), lr=LR, alpha=0.9)
opt_Adam = torch.optim.Adam(net_Adam.parameters(), lr=LR, betas=(0.9, 0.99))
optimizers = [opt_SGD, opt_Momentum, opt_RMSprop, opt_Adam]
</code></pre>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200323135943525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_1,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>
　　从图中可以看出，目前性能最优的应该是Adam。</p>
<h3 id="三、卷积神经网络-CNN">三、	卷积神经网络(CNN)</h3>
<p>图像处理中，不是对每个像素点卷积处理，而是对一小块区域进行计算，这样加强了图像信息的连续性，使得神经网络能看到图片信息而非一个点，同时加深了神经网络对图片的理解。批量过滤器每次对图像收集一小块信息，最后将这些整理出来得到边缘信息，再对这些信息进行类似的处理，得到更高层的信息结构(例如眼睛、鼻子等)，最后把总结出来的信息套入几层full connection进行分类等操作。卷积操作时，神经层会丢失一些信息，池化层可以将Layer中有用的信息筛选出来给下一层，因此图片的长宽不断压缩，压缩的工作是池化层进行的。</p>
<pre><code class="language-python">1、import需要的工具包和库：torch、torchvision、torch.nn、torch.utils.data
2、超参数：EPOCH、BATCH_SIZE、LR
3、下载mnist数据集：torchvision.datasets.MNIST(root='./mnist/',train=True,transform=torchvision.transform.ToTensor(),download=True)
 #root是保存或提取的位置，transform是将数据集PIL.Image or numpy.ndarray转换成torch.FloatTensor(C×H×W)，训练的时候normalize成[0,1]间的值
 test数据集处理：test—_x,test_y
 4、批训练train_loader定义：Data.DataLoader(dataset=train_data,batch_size=BATCH_SIZE,shuffle=True)
 5、定义网络构架CNN(nn.Module):conv1—conv2—RELU—pooling—conv2—ReLU—pooling—output
 网络计算流程：conv1(x)——conv2(x)——展平多维卷积图——计算输出
 6、定义optimizer和loss function
 7、训练和测试

</code></pre>
<h3 id="四、什么是LSTM循环卷积网络-RNN">四、什么是LSTM循环卷积网络(RNN)</h3>
<ul>
<li>LSTM(Long Short-Term Memory)——长短期记忆</li>
<li>RNN是在有序的数据上进行学习<br>
<img src="https://img-blog.csdnimg.cn/20200323202037102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM5MDc3,size_1,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li>
<li>分类问题(mnist数据集)<br>
　我们将图片数据看成一个时间上的连续数据, 每一行的像素点都是这个时刻的输入, 读完整张图片就是从上而下的读完了每行的像素点。然后我们就可以拿出 RNN 在最后一步的分析值判断图片是哪一类了。</li>
<li>回归问题<br>
这部分内容参考<a href="https://blog.csdn.net/qq_41639077/article/details/105218095" target="_blank" rel="noopener">KiKi的另一篇blog</a>，包括分类问题和回归问题的pytorch实现。</li>
</ul>
<h3 id="五、自编码-非监督学习（Autoencoder）">五、自编码/非监督学习（Autoencoder）</h3>
<p>原来有时神经网络要接受大量的输入信息, 比如输入信息是高清图片时, 输入信息量可能达到上千万, 让神经网络直接从上千万个信息源中学习是一件很吃力的工作。 所以, 何不<strong>压缩一下, 提取出原图片中的最具代表性的信息, 缩减输入信息量, 再把缩减过后的信息放进神经网络学习，这样学习起来就简单轻松了。</strong> 训练好的自编码中间这一部分就是能总结原数据的精髓，我们只用到了输入数据 X, 并没有用到 X 对应的数据标签, 所以也可以说自编码是一种非监督学习。到了真正使用自编码的时候，通常只会用到自编码前半部分。(摘自莫烦python)</p>
<ul>
<li>
<p>代码</p>
<pre><code class="language-python">self.encoder = nn.Sequential(
    nn.Linear(28*28, 128),
    nn.Tanh(),
    nn.Linear(128, 64),
    nn.Tanh(),
    nn.Linear(64, 12),
    nn.Tanh(),
    nn.Linear(12, 3),   # compress to 3 features which can be visualized in plt
)

self.decoder = nn.Sequential(
    nn.Linear(3, 12),
    nn.Tanh(),
    nn.Linear(12, 64),
    nn.Tanh(),
    nn.Linear(64, 128),
    nn.Tanh(),
    nn.Linear(128, 28*28),
    nn.Sigmoid(),       # compress to a range (0, 1)
)

def forward(self, x):
    encoded = self.encoder(x)
    decoded = self.decoder(encoded)
    return encoded, decoded

autoencoder = AutoEncoder()

</code></pre>
</li>
</ul>
<h3 id="六、GAN—生成对抗网络">六、GAN—生成对抗网络</h3>
<p>（原理已经学习过了，直接上代码）</p>
<ul>
<li>
<p>pytorch中实现：(代码中的对象不是图像，用到的是二次曲线) 　<br></p>
</li>
<li>
<p>超参数</p>
<pre><code>  ```python
  BATCH_SIZE = 64
  LR_G = 0.0001 # 生成器的学习率
  LR_D = 0.0001 # 判别器的学习率
  N_IDEAS = 5 # random_noise的个数
  ART_COMPONENTS = 15  # 定义规格，一条曲线上有多少个点
  PAINT_POINTS = np.vstack([np.linspace(-1,1,ART_COMPONENTS)for _ in range(BATCH_SIZE)]) # 规定整批画的点，从-1到1共15个点
  ```	
</code></pre>
</li>
<li>
<p>没有train data，自己伪造一些real data</p>
<pre><code>  ```python
  def artist_works():     # painting from the famous artist (real target)
      a = np.random.uniform(1, 2, size=BATCH_SIZE)[:, np.newaxis] # 二次曲线的系数
      paintings = a * np.power(PAINT_POINTS, 2) + (a-1)  # 二次曲线的参数，区间表示upper和
      paintings = torch.from_numpy(paintings).float()
      return paintings
  ```		
</code></pre>
</li>
<li>
<p>定义生成器和判别器</p>
<pre><code>  ```python
  G = nn.Sequential(                      # Generator
      nn.Linear(N_IDEAS, 128),            # random ideas (could from normal distribution)
      nn.ReLU(),
      nn.Linear(128, ART_COMPONENTS),     # making a painting from these random ideas
  )
  
  D = nn.Sequential(                      # Discriminator
      nn.Linear(ART_COMPONENTS, 128),     # receive art work either from the famous artist or a newbie like G
      nn.ReLU(),
      nn.Linear(128, 1),
      nn.Sigmoid(),                       # tell the probability that the art work is made by artist
  )
  ```
</code></pre>
</li>
<li>
<p>优化器</p>
<pre><code>  ```python
  	opt_D = torch.optim.Adam(D.parameters(), lr=LR_D)
  opt_G = torch.optim.Adam(G.parameters(), lr=LR_G)
  ```
</code></pre>
</li>
<li>
<p>训练啦</p>
<pre><code>  ```python
  for step in range(10000):
      artist_paintings = artist_works()           # real painting from artist
      G_ideas = torch.randn(BATCH_SIZE, N_IDEAS)  # random ideas
      G_paintings = G(G_ideas)                    # fake painting from G (random ideas)
  
      prob_artist0 = D(artist_paintings)          # D try to increase this prob
      prob_artist1 = D(G_paintings)               # D try to reduce this prob
  
      D_loss = - torch.mean(torch.log(prob_artist0) + torch.log(1. - prob_artist1))
      G_loss = torch.mean(torch.log(1. - prob_artist1))
  
      opt_D.zero_grad()
      D_loss.backward(retain_graph=True)      # reusing computational graph
      opt_D.step()
  
      opt_G.zero_grad()
      G_loss.backward()
      opt_G.step()
  ```
</code></pre>
</li>
</ul>
<p><strong>补充：</strong> cGAN与GAN的区别在于多了一个类别标签，这个label会跟随noise一起输入到生成器中，并且也要跟随fake和real一起输入到判别其中，最终计算各自的loss。</p>
<h3 id="七、为什么Torch是动态的-font-color-red-待补充-font">七、为什么Torch是动态的<font color="red">(待补充)</font></h3>
<p>例子：RNN网络<br>
　Tensorflow就是预先定义好要做的task的框架、步骤，然后开启会话之后喂数据一步到位的计算出结果，开启会话后便不能修改网络构架了，只能是照着计算流图跟着计算，所以是静态的；Torch也可以先定义好框架然后套进去，但计算的时候无论网络怎么变化每一个叶子节点的梯度都能给出，tensorflow就做不到这一点，并且torch是边给出计算图纸一边进行训练。torch就像是散装的一样，可以一块一块的制作好并进行计算，比较灵活，所以是动态的。</p>
<h3 id="八、GPU加速">八、GPU加速</h3>
<p>以之前CNN为例，对其代码进行修改</p>
<ul>
<li>
<p>dataset部分</p>
<pre><code class="language-python">test_x = torch.unsqueeze(test_data.test_data, dim=1).type(torch.FloatTensor).cuda()/255.   # Tensor on GPU
test_y = test_data.test_labels.cuda()
</code></pre>
</li>
<li>
<p>CNN网络的参数改为GPU兼容形式</p>
<pre><code class="language-python">class CNN(nn.Module):
    ...
cnn = CNN()
##########转换cnn到CUDA#########
cnn.cuda()   # Moves all model parameters and buffers to the GPU.
</code></pre>
</li>
<li>
<p>training data变成GPU形式</p>
<pre><code class="language-python">for epoch ..:
    for step, ...:
        ##########修改1###########
        b_x = x.cuda()    # Tensor on GPU
        b_y = y.cuda()    # Tensor on GPU
        ...

        if step % 50 == 0:
            test_output = cnn(test_x)

            # !!!!!!!! 修改2  !!!!!!!!! #
            pred_y = torch.max(test_output, 1)[1].cuda().data.squeeze()  # 将操作放去 GPU

            accuracy = torch.sum(pred_y == test_y) / test_y.size(0)
            ...

test_output = cnn(test_x[:10])

# !!!!!!!! 修改3 !!!!!!!!! #
pred_y = torch.max(test_output, 1)[1].cuda().data.squeeze()  # 将操作放去 GPU
...
print(test_y[:10], 'real number')
</code></pre>
</li>
</ul>
<h2 id="day-05">day 05</h2>
<h3 id="一、过拟合-Overfitting">一、过拟合(Overfitting)</h3>
<ul>
<li>
<p>过拟合（overfitting）是指在模型参数拟合过程中的问题，由于训练数据包含抽样误差，训练时，复杂的模型将抽样误差也考虑在内，将抽样误差也进行了很好的拟合。模型在训练集上效果好，然而在测试集上效果差，模型泛化能力差。</p>
</li>
<li>
<p>原因 <br><br>
　1）在对模型进行训练时，有可能遇到训练数据不够，即训练数据无法对整个数据的分布进行估计的时候； <br><br>
　2）权值学习迭代次数足够多(Overtraining),拟合了训练数据中的噪声和训练样例中没有代表性的特征。</p>
</li>
<li>
<p>解决方法</p>
<p>方法一： <strong>增加数据量</strong>。 <br><br>
方法二：<strong>运用正规化</strong>，L1、 L2 regularization等等。（神经网络的正规化方法<strong>dropout</strong>——就是在训练的时候, 随机忽略掉一些神经元和神经联结 , 使这个神经网络变得”不完整”，用这个不完整的神经网络训练一次。第二次再随机忽略另一些, 变成另一个不完整的神经网络。有了这些随机 drop 掉的规则, 我们可以想象每次训练的时候, 让每一次预测结果不会依赖于其中某部分特定的神经元。像l1, l2正规化一样, 过度依赖的 W  , 也就是训练参数的数值会很大, l1, l2会惩罚这些大的 参数，Dropout 的做法是从根本上让神经网络没机会过度依赖。）</p>
</li>
<li>
<p>Dropout</p>
<pre><code class="language-python"># 不加dropout的网络
net_overfitting = torch.nn.Sequential(
    torch.nn.Linear(1, N_HIDDEN),
    torch.nn.ReLU(),
    torch.nn.Linear(N_HIDDEN, N_HIDDEN),
    torch.nn.ReLU(),
    torch.nn.Linear(N_HIDDEN, 1),
    )
    
    # 加上dropout
net_dropped = torch.nn.Sequential(
    torch.nn.Linear(1, N_HIDDEN),
    torch.nn.Dropout(0.5),  # drop 50% of the neuron
    torch.nn.ReLU(),
    torch.nn.Linear(N_HIDDEN, N_HIDDEN),
    torch.nn.Dropout(0.5),  # drop 50% of the neuron
    torch.nn.ReLU(),
    torch.nn.Linear(N_HIDDEN, 1),
    )＃除了网络构架不同外，其他大同小异。
</code></pre>
</li>
</ul>
<p></p>
<h3 id="二、批标准化-Batch-Normalization">二、批标准化(Batch Normalization)</h3>
<ul>
<li>
<p>什么是批标准化 <br><br>
　Batch Normalization(BN), 批标准化, 和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法。 具有统一规格的数据, 能让机器学习更容易学习到数据之中的规律。数据随着神经网络的传递计算，激活函数的存在会造成网络层对数据的不敏感，比如0.1和2经过Tanh函数后，前者仍0.1，而2变成1，那这样再大的数都会变成1，所以神经层对数据失去了感觉，这样的问题同样存在于隐藏层中，所以BN则是用在这些神经层中优化网络的方法。 <br><br>
　Batch就是数据分批处理，每一批数据前向传递的过程中，每一层都进行BN处理，添加在层和激励函数之间。反BN：$BN_(\gamma,\beta)(x_i)$是将 normalize 后的数据再扩展和平移，是为了让神经网络自己去学着使用和修改这个扩展参数 $\gamma$, 和 平移参数$\beta$, 这样神经网络就能自己慢慢琢磨出前面的 normalization 操作到底有没有起到优化的作用, 如果没有起到作用, 我就使用 $\gamma$和$\beta$来抵消一些 normalization 的操作。</p>
</li>
<li>
<p>代码<br>
　莫烦<a href="https://github.com/MorvanZhou/PyTorch-Tutorial/blob/master/tutorial-contents/504_batch_normalization.py" target="_blank" rel="noopener">BN_code</a></p>
</li>
</ul>
<p><font color="red">部分内容待学习</font></p>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/work/">work</a>
                      &nbsp;
                    
                      <a class="hover-with-bg" href="/categories/work/pytorch%E5%AD%A6%E4%B9%A0/">pytorch学习</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/pytorch/">pytorch</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/03/30/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">视觉SLAM十四讲</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/18/%E6%96%87%E3%80%8AGround-to-Aeria-lImage-Geo-Localization-With-a-Hard-Exemplar-Reweighting-Triplet-Loss%E3%80%8B/">
                        <span class="hidden-mobile">论文《Ground-to-Aeria lImage Geo-Localization With a Hard Exemplar Reweighting Triplet Loss》</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
                   我在你身边，等着你回答
    </div>
  </div>


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>








<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "pytorch学习记录&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });
      MathJax.Hub.Register.StartupHook("End Jax",function () {
        var BROWSER = MathJax.Hub.Browser;
        var jax = "HTML-CSS";
        if (BROWSER.isMSIE && BROWSER.hasMathPlayer) jax = "NativeMML";
        return MathJax.Hub.setRenderer(jax);
      });
      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script  src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script>

  










</body>
</html>
